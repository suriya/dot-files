#!/usr/bin/env python2.5

#
# $Id: generate-jgraph 760 2007-03-19 15:45:14Z suriya $
#

# An example of a data file
# data,W16,W32
# art,1.0,2.0
# gzip,1.5,2.5
# mcf,2.0,3.0
#
# The first column in the first row is ignored.

import sys
import optparse
import csv

def transpose(data):
    num_rows = len(data)
    num_cols = len(data[0])
    null_list = [ None for i in data ]
    new_data = []
    for i in xrange(num_cols):
        new_data.append([])
        for j in xrange(num_rows):
            new_data[i].append(None)
    for i in xrange(num_rows):
        for j in xrange(num_cols):
            new_data[j][i] = data[i][j]
    return new_data

def smallerFont(fontsize):
    return fontsize/1.3

def largerFont(fontsize):
    return fontsize*1.3

def doCmdline():
    # Command line options
    usage = 'usage: %prog [OPTIONS] FILE'
    version = '%prog $Revision: 760 $'
    cmdline = optparse.OptionParser(usage=usage, version=version)
    cmdline.add_option("-x",   "--x_size",     type="float", default=5.0,                           help="set the SIZE (inches) of the X axis", metavar="SIZE")
    cmdline.add_option("-y",   "--y_size",     type="float", default=0.0,                           help="set the SIZE (inches) of the Y axis", metavar="SIZE")
    cmdline.add_option("--xl", "--x_label",                  default="",                          help="the label for the X axis",            metavar="XLABEL")
    cmdline.add_option("--yl", "--y_label",                  default="",                          help="the label for the Y axis",            metavar="YLABEL")
    cmdline.add_option("--tr", "--transpose",                default=False, action="store_true",  help="transpose the data in the file")
    cmdline.add_option("-b",   "--box_height", type="float", default=1.0,                         help="the height of boxes used in labels")
    cmdline.add_option("-s",   "--stack",      type="int",   default=0,                           help="stack every N rows", metavar="N")
    cmdline.add_option("-f",   "--fontsize",   type="float", default=12.0,                        help="specify the SIZE of the font", metavar="SIZE")
    cmdline.add_option("-n",   "--name_individual_bars",     default=False, action="store_true",  help="name the individual bars in a stacked barchart")
    cmdline.add_option("--ym", "--y_min",      type="float", default=0.0,                         help="minimum value in the Y axis")
    cmdline.add_option("--yh", "--y_hash",     type="float", default=-1.0,                        help="gap between Y axis hash marks")
    cmdline.add_option("--ymh","--y_minor_hash", type="int", default=-1.0,                        help="number of minor hash marks in the Y axis")
    cmdline.add_option("--ysh","--y_shash",    type="float", default=-1.0,                        help="surely draw a Y axis hash here")
    cmdline.add_option("--yg", "--y_grid_lines",             default=False, action="store_true",  help="draw grid lines along y axis")
    cmdline.add_option("-t",   "--text",                     default=[], action="append",         help="arbitrary text, in the format X Y Text")

    (options, args) = cmdline.parse_args()
    if(len(args) != 1):
        cmdline.error('Required argument FILE not specified')
        sys.exit(1)
    return (options, args)

def readDataFromFile(stream):
    data = []
    return [ row for row in csv.reader(stream) ]

def newgraphCode(stream, fontsize, x_size, y_size, x_min, x_max, y_min,
        x_label, y_label, y_hash, y_shash, y_minor_hashes, y_grid_lines):
    print >> stream, '(* Generated by generate-jgraph $Revision: 760 $. Do not modify this file *)'
    print >> stream, """
    newgraph
    legend defaults fontsize %f right
    xaxis hash 0 mhash 0 no_draw_hash_marks size %f min %f max %f label fontsize %f : %s
    yaxis size %f min %f hash %f shash %f mhash %d %s label fontsize %f : %s
    """ % (fontsize, x_size, x_min, x_max, largerFont(fontsize), x_label,
            y_size, y_min, y_hash, y_shash, y_minor_hashes, 'grid_lines' if y_grid_lines else '',
            largerFont(fontsize), y_label)

def arbitraryText(stream, fontsize, text):
    for t in text:
        l = t.strip().split()
        x = float(l[0])
        y = float(l[1])
        content = ' '.join(l[2:])
        print >> stream, "newstring hjl x %f y %f fontsize %f : %s" % (x, y, fontsize, content)

def barGraph(stream, data, labels_of_each_x_axis_point,
        labels_for_each_curve, fontsize, x_size, y_size, x_label, y_label,
        height_of_label_box, y_min, y_hash, y_shash, y_minor_hashes, y_grid_lines, text):
    """
    Draw a bargraph.

    data:                         an array containing the data. (should
                                  have dimensions:
                                  labels_of_each_x_axis_point * labels_for_each_curve)
    labels_of_each_x_axis_point:  The name of each xaxis point.
    labels_for_each_curve:        labels for different curves at each point
                                  in the x_axis (this will go into the legend)
    stream:                       where to write the output to
    x_size:                       size of the x_axis, in inches
    y_size:                       size of the y_axis, can be None to automatically compute the y_axis
    x_label:                      the x_axis label
    y_label:                      the y_axis label
    height_of_label_box:          the height of boxes in labels (this has
                                  to be adjusted to get the required size)
    """

    num_bars_for_a_point_in_xaxis = len(labels_for_each_curve)
    num_x_axis_points = len(labels_of_each_x_axis_point)
    assert len(data) == num_x_axis_points
    assert all(len(i) == num_bars_for_a_point_in_xaxis for i in data)

    # It is the intensity of the fill
    # case 0 has fill (1 - fill*0)
    # case 1 has fill (1 - fill*1)
    # case 2 has fill (1 - fill*2)
    fill  = 1.0/num_bars_for_a_point_in_xaxis

    # For a given benchmark, the combined width should be 0.6
    # That is there should be space of 0.2 on either side of a benchmark
    # The width x is the combined_width.
    # Set it to some number between zero and one and experiment
    #        
    #      |<-x->|      
    #      |-----|    |-----|    |-----|    |-----|                     
    # --------+----------+----------+----------+----------
    #         1          2          3          4            

    # It is the width of each individual bar. The combined width of all bars is
    # combined_width/(number of bars)
    combined_width = 0.6
    width = combined_width/num_bars_for_a_point_in_xaxis

    golden_ratio = 1.61803398875
    y_size = y_size if (y_size != 0) else (x_size / golden_ratio)
    x_min = combined_width/2.0
    x_max = num_x_axis_points + combined_width

    # zero point, where the xaxis starts
    zero_point = -(combined_width/2) + (width/2)

    # newgraph
    newgraphCode(stream, fontsize, x_size, y_size, x_min, x_max, y_min,
            x_label, y_label, y_hash, y_shash, y_minor_hashes, y_grid_lines)

    for i,label in enumerate(labels_for_each_curve):
        print >> stream, """
        newcurve
        marktype xbar marksize %f %f fill %f label : %s
        pts
        """ % (width, height_of_label_box, (1 - fill*i), label)
        for j,row in enumerate(data):
            print >> stream, '%f %f' % (zero_point + (width*i) + j+1, float(row[i]))

    print >> stream, 'xaxis hash_labels fontsize %f' % fontsize
    for i,name in enumerate(labels_of_each_x_axis_point):
        print >> stream, 'hash_label at %f : %s' % (i+1, name)

    arbitraryText(stream, fontsize, text)

def stackedBarGraph(stream, data, labels_for_each_stack,
        labels_of_each_x_axis_point, labels_for_each_curve, fontsize,
        x_size, y_size, x_label, y_label, height_of_label_box,
        name_individual_bars, y_min, y_hash, y_shash, y_minor_hashes, y_grid_lines, text):
    """
    Draw a bargraph.

    data:                         an array containing the data. (should
                                  have dimensions:
                                  labels_of_each_x_axis_point * labels_for_each_curve)
    labels_of_each_x_axis_point:  The name of each xaxis point.
    labels_for_each_curve:        labels for different curves at each point
                                  in the x_axis (this will go into the legend)
    stream:                       where to write the output to
    x_size:                       size of the x_axis, in inches
    y_size:                       size of the y_axis, can be None to automatically compute the y_axis
    x_label:                      the x_axis label
    y_label:                      the y_axis label
    height_of_label_box:          the height of boxes in labels (this has
                                  to be adjusted to get the required size)
    """

    num_stacks = len(labels_for_each_stack)
    num_bars_for_a_point_in_xaxis = len(labels_for_each_curve)
    num_x_axis_points = len(labels_of_each_x_axis_point)
    assert len(data) == (num_x_axis_points * num_stacks)
    assert all(len(i) == num_bars_for_a_point_in_xaxis for i in data)

    # It is the intensity of the fill
    # case 0 has fill (1 - fill*0)
    # case 1 has fill (1 - fill*1)
    # case 2 has fill (1 - fill*2)
    fill  = 1.0/num_stacks

    # For a given benchmark, the combined width should be 0.6
    # That is there should be space of 0.2 on either side of a benchmark
    # The width x is the combined_width.
    # Set it to some number between zero and one and experiment
    #        
    #      |<-x->|      
    #      |-----|    |-----|    |-----|    |-----|                     
    # --------+----------+----------+----------+----------
    #         1          2          3          4            

    # It is the width of each individual bar. The combined width of all bars is
    # combined_width/(number of bars)
    combined_width = 0.6
    width = combined_width/num_bars_for_a_point_in_xaxis

    golden_ratio = 1.61803398875
    y_size = y_size if y_size else (x_size / golden_ratio)
    if y_size is None:
        y_size = x_size / golden_ratio
    x_min = combined_width/2.0
    x_max = num_x_axis_points + combined_width

    # zero point, where the xaxis starts
    zero_point = -(combined_width/2) + (width/2)

    # newgraph
    newgraphCode(stream, fontsize, x_size, y_size, x_min, x_max, y_min,
            x_label, y_label, y_hash, y_shash, y_minor_hashes, y_grid_lines)

    for i,label in enumerate(reversed(labels_for_each_stack)):
        i = (num_stacks - i - 1)
        print >> stream, """
        newcurve
        marktype xbar marksize %f %f fill %f label : %s
        pts
        """ % (width, height_of_label_box, (1 - fill*i), label)
        for j in xrange(num_bars_for_a_point_in_xaxis):
            for k in xrange(num_x_axis_points):
                print >> stream, "%f %f" % (zero_point + (width*j) + (k+1), float(data[(i*num_x_axis_points)+k][j]))

    if name_individual_bars:
        for j in xrange(num_bars_for_a_point_in_xaxis):
            for k in xrange(num_x_axis_points):
                print >> stream, "newstring hjl rotate 90 x %f y 101 fontsize %f : %s" % (
                        (zero_point + (width*j) + (k+1) + (width/2.0), fontsize, labels_for_each_curve[j]))


    print >> stream, 'xaxis hash_labels fontsize %f' % fontsize
    for i,name in enumerate(labels_of_each_x_axis_point):
        print >> stream, 'hash_label at %f : %s' % (i+1, name)

    arbitraryText(stream, fontsize, text)


def doAll():
    (options, args) = doCmdline()
    # Read data from file
    data_file = args[0]
    data = readDataFromFile(file(data_file, 'r'))
    # Transpose if necessary
    data = transpose(data) if options.tr else data
    if options.stack > 1:
        stack_every = options.stack
        # Get the labels
        labels_for_each_stack = [ row[0] for i,row in enumerate(data) if (i%stack_every == 0) ]
        labels_of_each_x_axis_point = [ row[0] for row in data[1:stack_every] ]
        labels_for_each_curve = data[0][1:]
        data = [ row[1:] for i,row in enumerate(data) if (i%stack_every != 0) ]
        # Draw the Stacked bar graph
        stackedBarGraph(sys.stdout, data, labels_for_each_stack,
            labels_of_each_x_axis_point, labels_for_each_curve,
            options.fontsize, options.x_size, options.y_size,
            options.xl, options.yl,
            options.box_height, options.name_individual_bars, options.ym,
            options.yh, options.ysh, options.ymh, options.yg, options.text)
    else:
        # Get the labels
        labels_of_each_x_axis_point = [ i[0] for i in data[1:] ]
        labels_for_each_curve = data[0][1:]
        data = [ i[1:] for i in data[1:] ]
        # Draw the bar graph
        barGraph(sys.stdout, data, labels_of_each_x_axis_point,
                labels_for_each_curve, options.fontsize, options.x_size,
                options.y_size, options.xl, options.yl, options.box_height,
                options.ym, options.yh, options.ysh, options.ymh, options.yg, options.text)

doAll()
